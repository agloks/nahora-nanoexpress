'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var uWS = _interopDefault(require('uWebSockets.js'));
var cookie = _interopDefault(require('cookie'));
var querystring = require('querystring');
var stream$1 = require('stream');
var fs = require('fs');
var zlib = require('zlib');
var http = _interopDefault(require('http'));
var fastJson = _interopDefault(require('fast-json-stringify'));
var turboJsonParse = _interopDefault(require('turbo-json-parse'));
var Events = _interopDefault(require('@dalisoft/events'));
var Ajv = _interopDefault(require('ajv'));

var headers = (req, schema) => {
  let headers;
  if (schema) {
    const { properties } = schema;
    for (const property in properties) {
      if (!headers) {
        headers = {};
      }
      headers[property] = req.getHeader(property);
    }

    // This shit makes all plugins go wrong
    headers.origin = req.getHeader('origin');

    return headers;
  } else if (schema !== false) {
    req.forEach((key, value) => {
      if (!headers) {
        headers = {};
      }
      headers[key] = value;
    });
  }
  return headers;
};

var cookies = (req, schema) => {
  let cookies;
  const { headers } = req;
  const headerCookie =
    (headers && headers.cookie) || (req && req.getHeader('cookie'));

  if (headerCookie) {
    if (cookies) {
      const parsedCookie = cookie.parse(headerCookie);
      if (schema) {
        const { properties } = schema;
        for (const cookie in properties) {
          cookies[cookie] = parsedCookie[cookie];
        }
      } else {
        for (const cookie in parsedCookie) {
          cookies[cookie] = parsedCookie[cookie];
        }
      }
    } else if (!cookies) {
      cookies = cookie.parse(headerCookie);
    }
  }
  return cookies;
};

var queries = (req) => {
  const query = req.getQuery();

  let queries;
  if (!query) {
    return queries;
  }
  const parsed = querystring.parse(query);

  for (const query in parsed) {
    // On-Demand attaching for memory reason
    if (!queries) {
      queries = {};
    }

    queries[query] = parsed[query];
  }
  return queries;
};

const SPACE_TRIM_REGEX = /\n|\t/g;

var body = (req) =>
  req.stream &&
  new Promise((resolve, reject) => {
    let buffer;

    req.stream.on('data', (chunk) => {
      buffer = buffer ? Buffer.concat([buffer, chunk]) : chunk;
    });
    req.stream.once('end', () => {
      req.buffer = buffer;
      req.body = buffer
        ? buffer.toString('utf8').replace(SPACE_TRIM_REGEX, '')
        : null;
      resolve();
    });
    req.stream.once('error', (err) => {
      req.stream.destroy();
      reject(err);
    });
  });

function stream (req, res) {
  const stream = new stream$1.Readable({
    read() {}
  });

  req.stream = stream;

  res.onData((chunk, isLast) => {
    stream.push(Buffer.concat([Buffer.from(chunk)]));
    if (isLast) {
      stream.push(null);
    }
  });
}

var params = (req, matches) => {
  let params;
  if (matches) {
    if (!params && matches.length > 0) {
      params = {};
    }
    for (let i = 0, len = matches.length; i < len; i++) {
      params[matches[i]] = req.getParameter(i);
    }
  }

  return params;
};

function pipe (stream) {
  stream.write(this.buffer);
  stream.end();

  return this;
}

const mimes = {
  '3gp': 'video/3gpp',
  a: 'application/octet-stream',
  ai: 'application/postscript',
  aif: 'audio/x-aiff',
  aiff: 'audio/x-aiff',
  asc: 'application/pgp-signature',
  asf: 'video/x-ms-asf',
  asm: 'text/x-asm',
  asx: 'video/x-ms-asf',
  atom: 'application/atom+xml',
  au: 'audio/basic',
  avi: 'video/x-msvideo',
  bat: 'application/x-msdownload',
  bin: 'application/octet-stream',
  bmp: 'image/bmp',
  bz2: 'application/x-bzip2',
  c: 'text/x-c',
  cab: 'application/vnd.ms-cab-compressed',
  cc: 'text/x-c',
  chm: 'application/vnd.ms-htmlhelp',
  class: 'application/octet-stream',
  com: 'application/x-msdownload',
  conf: 'text/plain',
  cpp: 'text/x-c',
  crt: 'application/x-x509-ca-cert',
  css: 'text/css',
  csv: 'text/csv',
  cxx: 'text/x-c',
  deb: 'application/x-debian-package',
  der: 'application/x-x509-ca-cert',
  diff: 'text/x-diff',
  djv: 'image/vnd.djvu',
  djvu: 'image/vnd.djvu',
  dll: 'application/x-msdownload',
  dmg: 'application/octet-stream',
  doc: 'application/msword',
  dot: 'application/msword',
  dtd: 'application/xml-dtd',
  dvi: 'application/x-dvi',
  ear: 'application/java-archive',
  eml: 'message/rfc822',
  eps: 'application/postscript',
  exe: 'application/x-msdownload',
  f: 'text/x-fortran',
  f77: 'text/x-fortran',
  f90: 'text/x-fortran',
  flv: 'video/x-flv',
  for: 'text/x-fortran',
  gem: 'application/octet-stream',
  gemspec: 'text/x-script.ruby',
  gif: 'image/gif',
  gz: 'application/x-gzip',
  h: 'text/x-c',
  hh: 'text/x-c',
  htm: 'text/html',
  html: 'text/html',
  ico: 'image/vnd.microsoft.icon',
  ics: 'text/calendar',
  ifb: 'text/calendar',
  iso: 'application/octet-stream',
  jar: 'application/java-archive',
  java: 'text/x-java-source',
  jnlp: 'application/x-java-jnlp-file',
  jpeg: 'image/jpeg',
  jpg: 'image/jpeg',
  js: 'application/javascript',
  json: 'application/json',
  log: 'text/plain',
  m3u: 'audio/x-mpegurl',
  m4v: 'video/mp4',
  man: 'text/troff',
  mathml: 'application/mathml+xml',
  mbox: 'application/mbox',
  mdoc: 'text/troff',
  me: 'text/troff',
  mid: 'audio/midi',
  midi: 'audio/midi',
  mime: 'message/rfc822',
  mjs: 'application/javascript',
  mml: 'application/mathml+xml',
  mng: 'video/x-mng',
  mov: 'video/quicktime',
  mp3: 'audio/mpeg',
  mp4: 'video/mp4',
  mp4v: 'video/mp4',
  mpeg: 'video/mpeg',
  mpg: 'video/mpeg',
  ms: 'text/troff',
  msi: 'application/x-msdownload',
  odp: 'application/vnd.oasis.opendocument.presentation',
  ods: 'application/vnd.oasis.opendocument.spreadsheet',
  odt: 'application/vnd.oasis.opendocument.text',
  ogg: 'application/ogg',
  p: 'text/x-pascal',
  pas: 'text/x-pascal',
  pbm: 'image/x-portable-bitmap',
  pdf: 'application/pdf',
  pem: 'application/x-x509-ca-cert',
  pgm: 'image/x-portable-graymap',
  pgp: 'application/pgp-encrypted',
  pkg: 'application/octet-stream',
  pl: 'text/x-script.perl',
  pm: 'text/x-script.perl-module',
  png: 'image/png',
  pnm: 'image/x-portable-anymap',
  ppm: 'image/x-portable-pixmap',
  pps: 'application/vnd.ms-powerpoint',
  ppt: 'application/vnd.ms-powerpoint',
  ps: 'application/postscript',
  psd: 'image/vnd.adobe.photoshop',
  py: 'text/x-script.python',
  qt: 'video/quicktime',
  ra: 'audio/x-pn-realaudio',
  rake: 'text/x-script.ruby',
  ram: 'audio/x-pn-realaudio',
  rar: 'application/x-rar-compressed',
  rb: 'text/x-script.ruby',
  rdf: 'application/rdf+xml',
  roff: 'text/troff',
  rpm: 'application/x-redhat-package-manager',
  rss: 'application/rss+xml',
  rtf: 'application/rtf',
  ru: 'text/x-script.ruby',
  s: 'text/x-asm',
  sgm: 'text/sgml',
  sgml: 'text/sgml',
  sh: 'application/x-sh',
  sig: 'application/pgp-signature',
  snd: 'audio/basic',
  so: 'application/octet-stream',
  svg: 'image/svg+xml',
  svgz: 'image/svg+xml',
  swf: 'application/x-shockwave-flash',
  t: 'text/troff',
  tar: 'application/x-tar',
  tbz: 'application/x-bzip-compressed-tar',
  tcl: 'application/x-tcl',
  tex: 'application/x-tex',
  texi: 'application/x-texinfo',
  texinfo: 'application/x-texinfo',
  text: 'text/plain',
  tif: 'image/tiff',
  tiff: 'image/tiff',
  torrent: 'application/x-bittorrent',
  tr: 'text/troff',
  txt: 'text/plain',
  vcf: 'text/x-vcard',
  vcs: 'text/x-vcalendar',
  vrml: 'model/vrml',
  war: 'application/java-archive',
  wav: 'audio/x-wav',
  wma: 'audio/x-ms-wma',
  wmv: 'video/x-ms-wmv',
  wmx: 'video/x-ms-wmx',
  wrl: 'model/vrml',
  wsdl: 'application/wsdl+xml',
  xbm: 'image/x-xbitmap',
  xhtml: 'application/xhtml+xml',
  xls: 'application/vnd.ms-excel',
  xml: 'application/xml',
  xpm: 'image/x-xpixmap',
  xsl: 'application/xml',
  xslt: 'application/xslt+xml',
  yaml: 'text/yaml',
  yml: 'text/yaml',
  zip: 'application/zip',
  default: 'text/html'
};

const getMime = (path) => {
  const i = path.lastIndexOf('.');
  return mimes[path.substr(i + 1).toLowerCase()];
};

function sendFile (path, lastModified = true, compressed = false) {
  const res = this;
  const req = res.__request;
  const { headers } = req;
  const responseHeaders = {};

  const stat = fs.statSync(path);
  let { size } = stat;

  // handling last modified
  if (lastModified) {
    const { mtime } = stat;

    mtime.setMilliseconds(0);
    const mtimeutc = mtime.toUTCString();

    // Return 304 if last-modified
    if (headers && headers['if-modified-since']) {
      if (new Date(headers['if-modified-since']) >= mtime) {
        res.writeStatus('304 Not Modified');
        return res.end();
      }
    }
    responseHeaders['last-modified'] = mtimeutc;
  }
  responseHeaders['content-type'] = getMime(path);

  // write data
  let start = 0;
  let end = 0;

  if (headers && headers.range) {
    [start, end] = headers.range
      .substr(6)
      .split('-')
      .map((byte) => (byte ? parseInt(byte, 10) : undefined));

    // Chrome patch for work
    if (end === undefined) {
      end = size - 1;
    }

    if (start !== undefined) {
      res.writeStatus('206 Partial Content');
      responseHeaders['accept-ranges'] = 'bytes';
      responseHeaders['content-range'] = `bytes ${start}-${end}/${size}`;
      size = end - start + 1;
    }
  }

  // for size = 0
  if (end < 0) {
    end = 0;
  }

  req.responseHeaders = responseHeaders;

  const createStreamInstance = end
    ? fs.createReadStream(path, { start, end })
    : fs.createReadStream(path);

  const pipe = res.pipe(createStreamInstance, size, compressed);
  res.writeHeaders(responseHeaders);

  return pipe;
}

function modifyEnd() {
  if (!this._modifiedEnd) {
    const _oldEnd = this.end;

    this.end = function (chunk, encoding) {
      // eslint-disable-next-line prefer-const
      let { _headers, statusCode, rawStatusCode } = this;

      // Polyfill for express-session and on-headers module
      if (!this.writeHead.notModified) {
        this.writeHead(statusCode || rawStatusCode, _headers);
        this.writeHead.notModified = true;
        _headers = this._headers;
      }

      if (typeof statusCode === 'number' && statusCode !== rawStatusCode) {
        this.status(statusCode);
        statusCode = this.statusCode;
      }
      if (_headers) {
        if (statusCode && statusCode !== rawStatusCode) {
          this.writeStatus(statusCode);
        }

        this.applyHeadersAndStatus();
      } else if (statusCode && statusCode !== rawStatusCode) {
        this.writeStatus(statusCode);
      }

      return encoding
        ? _oldEnd.call(this, chunk, encoding)
        : _oldEnd.call(this, chunk);
    };

    this._modifiedEnd = true;
  }
  return this;
}

function send(result) {
  if (!result) {
    result = '';
  } else if (typeof result === 'object') {
    this.setHeader('Content-Type', 'application/json; charset=utf-8');

    const { fastJson, rawStatusCode: statusCode } = this;

    if (fastJson) {
      if (typeof fastJson === 'function') {
        result = fastJson(result);
      } else if (fastJson && typeof fastJson[statusCode] === 'function') {
        result = fastJson[statusCode](result);
      } else {
        const _statusCode = statusCode + '';
        for (let code in fastJson) {
          const fastJsonFunc = fastJson[code];
          if (code === _statusCode) {
            result = fastJsonFunc(result);
          } else if (code.indexOf('X') !== -1) {
            for (let i = 0; i < 3; i++) {
              if (code.charAt(i) === 'X') {
                code =
                  code.substr(0, i) +
                  _statusCode.charAt(i) +
                  code.substr(i, code.length - (i + 1));
              }
            }

            if (code == _statusCode) {
              result = fastJsonFunc(result);
            }
          }
        }
      }
    } else {
      result = JSON.stringify(result);
    }
  }

  return this.end(result);
}

function type(type) {
  this.setHeader('Content-Type', type);

  return this;
}

const priority = ['gzip', 'br', 'deflate'];

var compressStream = (stream, headers) => {
  const contentEncoding = headers['accept-encoding'];
  const encoding = priority.find(
    (encoding) => contentEncoding && contentEncoding.indexOf(encoding) !== -1
  );

  const compression =
    encoding === 'br'
      ? zlib.createBrotliCompress()
      : encoding === 'gzip'
      ? zlib.createGzip()
      : encoding === 'deflate'
      ? zlib.createDeflate()
      : null;

  if (compression) {
    stream.pipe(compression);

    headers['Content-Encoding'] = encoding;
  }

  return compression;
};

function pipe$1 (stream, size, compressed = false) {
  const { __request: req } = this;
  const { onAborted, headers, responseHeaders } = req;
  let isAborted = false;

  this.stream = true;

  if (compressed) {
    const compressedStream = compressStream(stream, responseHeaders || headers);

    if (compressedStream) {
      stream = compressedStream;
    }
  }

  onAborted(() => {
    if (stream) {
      stream.destroy();
    }
    if (stream) {
      stream.destroy();
    }
    isAborted = true;
  });

  if (compressed || !size) {
    stream.on('data', (buffer) => {
      if (isAborted) {
        stream.destroy();
        return;
      }
      this.write(
        buffer.buffer.slice(
          buffer.byteOffset,
          buffer.byteOffset + buffer.byteLength
        )
      );
    });
  } else {
    stream.on('data', (buffer) => {
      if (isAborted) {
        stream.destroy();
        return;
      }
      buffer = buffer.buffer.slice(
        buffer.byteOffset,
        buffer.byteOffset + buffer.byteLength
      );
      const lastOffset = this.getWriteOffset();

      // First try
      const [ok, done] = this.tryEnd(buffer, size);

      if (done) {
        stream.destroy();
      } else if (!ok) {
        // pause because backpressure
        stream.pause();

        // Register async handlers for drainage
        this.onWritable((offset) => {
          const [ok, done] = this.tryEnd(
            buffer.slice(offset - lastOffset),
            size
          );
          if (done) {
            stream.end();
          } else if (ok) {
            stream.resume();
          }
          return ok;
        });
      }
    });
  }
  stream
    .on('error', () => {
      this.stream = -1;
      if (!isAborted) {
        this.writeStatus('500 Internal server error');
        this.end();
      }
      stream.destroy();
    })
    .on('end', () => {
      this.stream = 1;
      if (!isAborted) {
        this.end();
      }
    });

  return this;
}

var HttpResponseChunks = /*#__PURE__*/Object.freeze({
  __proto__: null,
  modifyEnd: modifyEnd,
  send: send,
  type: type,
  pipe: pipe$1
});

function setCookie(name, value, options) {
  if (options.expires && Number.isInteger(options.expires)) {
    options.expires = new Date(options.expires);
  }
  const serialized = cookie.serialize(name, value, options);

  let setCookie = this.getHeader('Set-Cookie');

  if (!setCookie) {
    this.setHeader('Set-Cookie', serialized);
    return undefined;
  }

  if (typeof setCookie === 'string') {
    setCookie = [setCookie];
  }

  setCookie.push(serialized);

  this.removeHeader('Set-Cookie');
  this.setHeader('Set-Cookie', setCookie);
  return this;
}

function hasCookie(name) {
  const req = this.__request;
  return !!req && !!req.cookies && req.cookies[name] !== undefined;
}

function removeCookie(name, options = {}) {
  const currTime = Date.now();
  if (!options.expires || options.expires >= currTime) {
    options.expires = currTime - 1000;
  }
  this.setCookie(name, '', options);
  return this;
}

var HttpCookieResponseChunks = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setCookie: setCookie,
  hasCookie: hasCookie,
  removeCookie: removeCookie
});

const HttpCookieResponse = {
  ...HttpCookieResponseChunks
};

// Alias for Express users
HttpCookieResponse.cookie = HttpCookieResponse.setCookie;

function setHeader(key, value) {
  !this._modifiedEnd && this.modifyEnd();

  if (!this._headers) {
    this._headers = {};
  }
  this._headers[key] = value;
  return this;
}

function getHeader(key) {
  return !!this._headers && !!key && this._headers[key];
}

function hasHeader(key) {
  return (
    !!this._headers &&
    this._headers[key] !== undefined &&
    this._headers[key] !== null
  );
}

function removeHeader(key) {
  if (!this._headers || !this._headers[key]) {
    return undefined;
  }
  !this._modifiedEnd && this.modifyEnd();
  this._headers[key] = null;
  delete this._headers[key];

  return this;
}

function setHeaders(headers) {
  for (const header in headers) {
    if (this._headers) {
      const currentHeader = this._headers[header];
      if (currentHeader !== undefined || currentHeader !== null) {
        continue;
      }
    }
    this.setHeader(header, headers[header]);
  }

  return this;
}

function writeHeaderValues(header, values) {
  for (let i = 0, len = values.length; i < len; i++) {
    this.writeHeader(header, values[i] + '');
  }
}

function writeHeaders(headers) {
  for (const header in headers) {
    const value = headers[header];
    if (value) {
      if (value.splice) {
        this.writeHeaderValues(header, value);
      } else {
        this.writeHeader(header, value + '');
      }
    }
  }
  return this;
}

function applyHeadersAndStatus() {
  const { _headers, statusCode } = this;

  if (typeof statusCode === 'string') {
    this.writeStatus(statusCode);
    this.statusCode = 200;
  }

  for (const header in _headers) {
    const value = _headers[header];

    if (value) {
      if (value.splice) {
        this.writeHeaderValues(header, value);
      } else {
        this.writeHeader(header, value + '');
      }
      this.removeHeader(header);
    }
  }

  return this;
}

var HttpHeaderResponseChunks = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setHeader: setHeader,
  getHeader: getHeader,
  hasHeader: hasHeader,
  removeHeader: removeHeader,
  setHeaders: setHeaders,
  writeHeaderValues: writeHeaderValues,
  writeHeaders: writeHeaders,
  applyHeadersAndStatus: applyHeadersAndStatus
});

const HttpHeaderResponse = {
  ...HttpHeaderResponseChunks
};

HttpHeaderResponse.header = HttpHeaderResponse.setHeader;

function status(code, notModify) {
  if (!notModify && this.modifyEnd && !this._modifiedEnd) {
    this.modifyEnd();
  }

  if (typeof code === 'string') {
    this.statusCode = code;
    this.rawStatusCode = parseInt(code);
  } else if (http.STATUS_CODES[code] !== undefined) {
    this.statusCode = code + ' ' + http.STATUS_CODES[code];
    this.rawStatusCode = code;
  } else {
    throw new Error('Invalid Code: ' + JSON.stringify(code));
  }

  return this;
}

function writeHead(code, headers) {
  if (typeof code === 'object' && !headers) {
    headers = code;
    code = 200;
  }

  if (code !== undefined && code !== 200) {
    this.status(code);
  }
  if (headers !== undefined) {
    this.setHeaders(headers);
  }

  return this;
}

const HTTP_PREFIX = 'http://';
const HTTPS_PREFIX = 'https://';

const normalizeLocation = (path, config, host) => {
  if (path.indexOf('http') === -1) {
    if (path.indexOf('/') === -1) {
      path = '/' + path;
    }
    let httpHost;
    if (host) {
      httpHost = host;
    } else if (config && config.host) {
      httpHost = config.host;
      httpHost += config.port ? `:${config.port}` : '';
    }
    if (httpHost) {
      path =
        (config && config.https ? HTTPS_PREFIX : HTTP_PREFIX) + httpHost + path;
    }
  }
  return path;
};

function redirect(code, path) {
  const { __request, config } = this;
  const host = __request && __request.headers && __request.headers.host;

  if (!path && typeof code === 'string') {
    path = code;
    code = 301;
  }

  let Location = '';
  if (path) {
    Location = normalizeLocation(path, config, host);
  }

  this.writeHead(code, { Location });
  this.end();

  return this;
}

/** global: Buffer */

function getResponseIp () {
  // Detect self
  const _self = this.send ? this : this.__response;

  return Buffer.from(_self.getRemoteAddress()).join('.');
}

var HttpResponsePolyfillChunks = /*#__PURE__*/Object.freeze({
  __proto__: null,
  status: status,
  writeHead: writeHead,
  redirect: redirect,
  _getResponseIP: getResponseIp
});

const HttpResponsePolyfill = {
  ...HttpResponsePolyfillChunks
};

const HttpResponse = {
  ...HttpHeaderResponse,
  ...HttpCookieResponse,
  ...HttpResponseChunks,
  ...HttpResponsePolyfill
};

// Aliases for beginners and/or users from Express!
HttpResponse.json = HttpResponse.send;

// Add stream feature by just method
// for easy and clean code
HttpResponse.sendFile = sendFile;

const nonSimpleProps = ['query', 'cookies', 'body'].map(
  (prop) => `req.${prop}`
);
const matchers = (raw, prop) =>
  raw.includes(`.${prop}`) ||
  raw.includes(`{ ${prop}`) ||
  raw.includes(`${prop} }`) ||
  raw.includes(`, ${prop}`) ||
  raw.includes(`${prop},`);

const allowedMethods = ['status', 'setHeader'];
const nonSimpleMethods = Object.keys(HttpResponse)
  .filter((method) => !allowedMethods.includes(method))
  .map((method) => `res.${method}`);

// eslint-disable-next-line no-useless-escape
const HEADER_PARAM_KEY_REGEX = /['"`;(){}\[\]]/g;
const HEADER_PARAM_KEY_CONST_REGEX = /(\{(.*)\})?\s+?=?\s+req./m;
const RETURN_TRIP_REGEX = /;/g;
const ARGUMENTS_MATCH_REG_EX = /\((req|res)\)/;
const DIRECT_SIMPLE_ASYNC_REG_EX = /async?\s+\((.*)\)\s+=>?\s+(.*)/g;

const convertParams = (params) => {
  if (!params) {
    return null;
  }
  const _params = {};
  for (let i = 0, len = params.length; i < len; i++) {
    _params[params[i]] = i;
  }
  return _params;
};
const babelCompilerManipulationNormalize = (content) => {
  if (content.includes('const {\n') || content.includes('let {\n')) {
    return content.split('\n').reduce((all, currLine, index) => {
      if (currLine.includes('{') && index > 0) {
        all += '\n';
      }
      if (index > 0 && (currLine.includes(';') || currLine.includes('}'))) {
        currLine += '\n';
      }

      return all + currLine;
    }, '');
  } else {
    return content;
  }
};

function compileRoute(fn, params) {
  const content = babelCompilerManipulationNormalize(fn.toString().trim());
  const preparedParams = convertParams(params);

  // Don't parse dummy functions
  if (content === '() => {}') {
    return (req, res) => res.end('');
  }

  const lines = content.split('\n');

  let argumentsLine = lines.shift().trim();

  if (lines.length === 0) {
    if (argumentsLine.includes('async () =>')) {
      return compileRoute(
        argumentsLine.replace(
          DIRECT_SIMPLE_ASYNC_REG_EX,
          '($1) => {\nres.end($2)\n}'
        )
      );
    }
  }

  let returnLine = lines.pop();
  let buffyReturnLine = '';

  // Dirty fastest check for Simple function
  for (const prop of nonSimpleProps) {
    if (content.includes(prop)) {
      return null;
    }
  }

  // Dirty fastest check for Simple function
  for (const method of nonSimpleMethods) {
    if (content.includes(method)) {
      return null;
    }
  }

  if (argumentsLine.includes('async') && !content.includes('await')) {
    argumentsLine = argumentsLine.substr(5);
  }

  if (!argumentsLine.includes('(req, res)')) {
    if (argumentsLine.includes('(req)') || argumentsLine.includes('(res)')) {
      argumentsLine = argumentsLine.replace(
        ARGUMENTS_MATCH_REG_EX,
        '(req, res)'
      );
    } else {
      argumentsLine =
        '(req, res) ' + argumentsLine.substr(argumentsLine.indexOf('()') + 2);
    }
  }

  if (returnLine === '}' && lines.length > 0) {
    buffyReturnLine = returnLine;
    returnLine = lines.pop();
  }

  if (returnLine) {
    if (returnLine.includes('return')) {
      const tripLeft = returnLine.trim().substr(7);
      returnLine = `res.end(${tripLeft.replace(RETURN_TRIP_REGEX, '')})`;

      returnLine = `res.end(${tripLeft.replace(RETURN_TRIP_REGEX, '')})`;
    }
    if (returnLine.includes('(({')) {
      returnLine = returnLine.replace(/\(\(/g, '(');
    }
    if (returnLine.includes('}))')) {
      returnLine = returnLine.replace(/\)\)/g, ')');
    }
    if (returnLine.includes('({')) {
      returnLine = returnLine.replace(
        /res\.end\((.*)\)/g,
        'res.end(JSON.stringify($1))'
      );
    }
  }

  let contentLines = argumentsLine + '\n';

  if (lines.length > 0) {
    for (const line of lines) {
      if (line.includes('//')) {
        continue;
      }

      if (line.includes('req.headers')) {
        const headerKeyIndex = line.indexOf('req.headers');
        if (headerKeyIndex !== -1) {
          const headerKey = line
            .substr(headerKeyIndex + 12)
            .replace(HEADER_PARAM_KEY_REGEX, '');

          if (line.charAt(headerKeyIndex + 11) === '.') {
            contentLines += line.replace(
              'req.headers.' + headerKey,
              "req.getHeader('" + headerKey + "')"
            );
          } else if (line.charAt(headerKeyIndex + 11) === '[') {
            contentLines += line.replace(
              "req.headers['" + headerKey + "']",
              "req.getHeader('" + headerKey + "')"
            );
          } else if (line.includes('req.headers;')) {
            const matchDefine = line.includes('const') ? 'const' : 'let';
            const extractConstants = line.match(HEADER_PARAM_KEY_CONST_REGEX);
            const leftPad = line.indexOf(matchDefine);

            if (extractConstants && extractConstants[2]) {
              const constants = extractConstants[2].trim().split(',');

              for (const header of constants) {
                contentLines += `${' '.repeat(
                  leftPad
                )}${matchDefine} ${header} = req.getHeader('${header}');`;
              }
            }
          } else {
            return null;
          }
        }
      } else if (line.includes('req.params')) {
        const paramKeyIndex = line.indexOf('req.params');

        if (paramKeyIndex !== -1) {
          const paramKey = line
            .substr(paramKeyIndex + 11)
            .replace(HEADER_PARAM_KEY_REGEX, '');
          const paramIndex = preparedParams[paramKey];

          if (line.charAt(paramKeyIndex + 10) === '.') {
            contentLines += line.replace(
              'req.params.' + paramKey,
              "req.getParameter('" + paramIndex + "')"
            );
          } else if (line.charAt(paramKeyIndex + 10) === '[') {
            contentLines += line.replace(
              "req.params['" + paramKey + "']",
              "req.getParameter('" + paramIndex + "')"
            );
          } else if (line.includes('req.params;')) {
            const matchDefine = line.includes('const') ? 'const' : 'let';
            const extractConstants = line.match(HEADER_PARAM_KEY_CONST_REGEX);
            const leftPad = line.indexOf(matchDefine);

            if (extractConstants && extractConstants[2]) {
              const constants = extractConstants[2].trim().split(',');

              for (const param of constants) {
                contentLines += `${' '.repeat(
                  leftPad
                )}${matchDefine} ${param} = req.getParameter(${
                  preparedParams[param]
                });`;
              }
            }
          } else {
            return null;
          }
        }
      } else if (line.includes('setHeader')) {
        contentLines += line.replace('setHeader', 'writeHeader');
      } else if (line.includes('status(')) {
        const statusPrepare = line.substr(line.indexOf('status(') + 7);
        const code = parseInt(
          statusPrepare.substr(0, statusPrepare.indexOf(')')),
          10
        );

        if (typeof code === 'number' && !Number.isNaN(code)) {
          contentLines += line
            .replace('status', 'writeStatus')
            .replace(code, `'${code} ${http.STATUS_CODES[code]}'`);
        } else {
          contentLines += line;
        }
      } else {
        contentLines += line;
      }

      contentLines += '\n';
    }
  }
  if (returnLine) {
    contentLines += returnLine;
  }

  if (buffyReturnLine) {
    contentLines += '\n';
    contentLines += buffyReturnLine;
  }

  let compiled;
  try {
    compiled = new Function('return ' + contentLines)();
  } catch (e) {
    try {
      compiled = eval(contentLines);
    } catch (e) {
      compiled = null;
    }
  }

  if (compiled) {
    compiled.path = matchers(contentLines, 'path');
    compiled.method = matchers(contentLines, 'method');
  }

  return compiled;
}

var isHttpCode = (code) => {
  const codeInteger = +code;
  if (
    typeof codeInteger === 'number' &&
    codeInteger > 100 &&
    codeInteger < 600
  ) {
    return 1;
  } else if (
    typeof code === 'string' &&
    code.length === 3 &&
    code.indexOf('X') !== -1
  ) {
    return 2;
  }
  return 0;
};

const validationMethods = [
  'response',
  'query',
  'params',
  'cookies',
  'headers',
  'body'
];
const validationSchema = {
  type: 'object',
  properties: {
    type: { type: 'string' },
    errors: {
      type: 'object',
      properties: {
        headers: {
          type: 'array',
          items: { type: 'string' }
        },
        cookies: {
          type: 'array',
          items: { type: 'string' }
        },
        query: {
          type: 'array',
          items: { type: 'string' }
        },
        params: {
          type: 'array',
          items: { type: 'string' }
        },
        body: {
          type: 'array',
          items: { type: 'string' }
        }
      }
    }
  }
};

var prepareValidation = (ajv, schema) => {
  const validation = [];
  let validationStringify;
  let responseSchema;

  if (schema) {
    for (let i = 0, len = validationMethods.length, type; i < len; i++) {
      type = validationMethods[i];
      const _schema = schema[type];
      if (typeof _schema === 'object' && _schema) {
        if (type === 'response') {
          const isHttpCodes = Object.keys(_schema).every(isHttpCode);

          let newSchema;
          if (isHttpCodes) {
            newSchema = {};
            for (const code in _schema) {
              newSchema[code] = fastJson(_schema[code]);
            }
          } else {
            newSchema = fastJson(_schema);
          }

          responseSchema = newSchema;
        } else {
          if (ajv) {
            const validator = ajv.compile(_schema);
            validation.push({ type, validator, schema: _schema });
            if (!validationStringify) {
              validationStringify = fastJson(validationSchema);
            }
          }
        }
      }
    }
  }

  return {
    validation,
    validationStringify,
    responseSchema
  };
};

var processValidation = (req, res, config, { validationStringify, validation } = {}) => {
  if (validationStringify) {
    let errors;
    for (let i = 0, len = validation.length; i < len; i++) {
      const { type, validator, schema } = validation[i];

      const reqValue = req[type];

      if (reqValue === undefined) {
        if (schema && schema.required) {
          if (!errors) {
            errors = {
              type: 'errors',
              errors: { [type]: [type + ' is not missing'] }
            };
          } else {
            const _errors = errors.errors;

            if (_errors[type]) {
              _errors[type].push(type + ' is not missing');
            } else {
              _errors[type] = [type + ' is not missing'];
            }
          }
        }
        continue;
      }

      const valid = validator(reqValue);

      if (!valid) {
        if (!errors) {
          errors = {
            type: 'errors',
            errors: { [type]: validator.errors.map((err) => err.message) }
          };
        } else {
          const _errors = errors.errors;

          if (_errors[type]) {
            _errors[type].push(...validator.errors.map((err) => err.message));
          } else {
            _errors[type] = validator.errors.map((err) => err.message);
          }
        }
      }
    }

    if (errors) {
      if (config._validationErrorHandler) {
        const validationHandlerResult = config._validationErrorHandler(
          errors,
          req,
          res
        );

        if (validationHandlerResult && validationHandlerResult.errors) {
          errors = validationHandlerResult;
        } else {
          return config._validationErrorHandler(errors, req, res);
        }
      }
      res.writeHeader('400 Bad Request');
      res.writeHeader('Content-Type', 'application/json; charset=utf-8');
      return res.end(validationStringify(errors));
    }
  }
};

const swaggerPathNormalizeRegExp = /:(.*?[/])?(.*)/;
const swaggerPathNormalizeFunc = (matched) => {
  if (matched[0] === ':') {
    matched = matched.substr(1);

    let lastChar = '';
    if (matched && matched[matched.length - 1] === '/') {
      matched = matched.substr(0, matched.length - 1);
      lastChar = '/';
    }

    matched = '{' + matched + '}' + lastChar;
  }
  return matched;
};

function swaggerDocsGenerator(
  swaggerDef,
  path,
  method,
  { schema, contentType = '*', ...routeConfigs } = {}
) {
  if (!schema) {
    return;
  }
  if (swaggerDef.paths === undefined) {
    swaggerDef.paths = {};
  }

  if (path.indexOf(':') !== -1) {
    path = path.replace(swaggerPathNormalizeRegExp, swaggerPathNormalizeFunc);
  }

  // Quick patch for Swagger
  if (method === 'del') {
    method = 'delete';
  }

  for (const typeName in schema) {
    if (schema[typeName] === false) {
      continue;
    }

    const type =
      typeName === 'params'
        ? 'path'
        : typeName === 'response'
        ? 'responses'
        : typeName === 'body'
        ? 'requestBody'
        : typeName;

    if (swaggerDef.paths[path] === undefined) {
      swaggerDef.paths[path] = {};
    }

    const defPath = swaggerDef.paths[path];
    if (defPath[method] === undefined) {
      defPath[method] = routeConfigs;
    }

    const methodInstance = defPath[method];

    let schemaItem = schema[typeName];
    const schemaKeys = Object.keys(schemaItem).every(isHttpCode);

    if (typeName === 'security') {
      methodInstance[typeName] = schema[typeName];
      continue;
    } else if (
      typeName === 'query' ||
      typeName === 'params' ||
      typeName === 'headers'
    ) {
      if (!methodInstance.parameters) {
        methodInstance.parameters = [];
      }
      if (schemaItem.description && !methodInstance.description) {
        methodInstance.description = schemaItem.description;
      }
      for (const name in schemaItem.properties) {
        const value = schemaItem.properties[name];

        methodInstance.parameters.push({
          name,
          in: type,
          description: value.description,
          required:
            value.required ||
            (schemaItem.required && schemaItem.required.indexOf(name) !== -1),
          schema: value
        });
      }
      continue;
    } else if (!schemaKeys && typeName === 'response') {
      schema[typeName] = { 200: schemaItem };
    }
    schemaItem = schema[typeName];

    if (!schemaItem.content) {
      if (typeName === 'response') {
        for (const httpCode in schema[typeName]) {
          let value = schema[typeName][httpCode];
          let parent = value;

          if (!value.content) {
            schema[typeName][httpCode] = { content: { [contentType]: value } };
            parent = schema[typeName][httpCode];
            value = parent.content[contentType];
          }
          if (value.description && !parent.description) {
            parent.description = value.description;
          }

          if (!value.schema) {
            schema[typeName][httpCode].content[contentType] = { schema: value };
          }
        }
      } else {
        let value = schemaItem;
        let parent = value;

        if (!value.content) {
          schema[typeName] = { content: { [contentType]: value } };
          parent = schema[typeName];
          value = schema[typeName].content[contentType];
        }
        if (value.description && !parent.description) {
          parent.description = value.description;
        }

        if (!value.schema) {
          schema[typeName].content[contentType] = { schema: value };
        }
      }
    }

    methodInstance[type] = schema[typeName];
  }
}

var httpMethods = [
  'get',
  'post',
  'put',
  'patch',
  'del',
  'any',
  'head',
  'options',
  'trace'
];

const PARAMS_REGEX = /:([A-Za-z0-9_-]+)/g;

var prepareParams = (rawPath) => {
  if (rawPath.indexOf(':') !== -1) {
    const paramsArray = rawPath.match(PARAMS_REGEX);

    if (paramsArray) {
      return paramsArray.map((name) => name.substr(1));
    }
  }

  return null;
};

const resAbortHandler = '___$HttpResponseAbortHandler';
const __wsProto__ = Events.prototype;

class Route {
  constructor(config = {}) {
    this._config = config;
    this._ajv = config.ajv;
    this._middlewares = null;

    this._baseUrl = '';

    this._module = true;
    this._rootLevel = false;
  }
  use(path, ...middlewares) {
    let { _middlewares } = this;

    if (!_middlewares) {
      _middlewares = [];
      this._middlewares = _middlewares;
    }

    if (typeof path === 'function' || (path && path._module)) {
      middlewares.unshift(path);
      path = undefined;
    }

    _middlewares.push(...middlewares);

    for (let i = 0, len = _middlewares.length, middleware; i < len; i++) {
      middleware = _middlewares[i];
      if (!middleware) {
        continue;
      }
      if (middleware._module) {
        middleware._ajv = this._ajv;
        middleware._config = this._config;
        middleware._app = this._app;

        if (_middlewares && _middlewares.length > 0) {
          if (middleware._middlewares) {
            if (middleware._middlewares !== _middlewares) {
              middleware._middlewares = _middlewares
                .concat(middleware._middlewares)
                .filter(
                  (middleware, i, self) => self.indexOf(middleware) === i
                );
            }
          } else {
            middleware._middlewares = _middlewares.filter(
              (middleware, i, self) => self.indexOf(middleware) === i
            );
          }
        }

        if (typeof path === 'string') {
          middleware._baseUrl = path;
        } else {
          middleware._baseUrl = this._baseUrl;
          middleware._direct = true;
        }
      } else if (!middleware.path) {
        if (typeof path === 'string') {
          middleware._baseUrl = path;
        } else {
          middleware._direct = true;
          middleware._baseUrl = this._baseUrl;
        }
      }
      middleware.discard =
        (!middleware._module &&
          /res\.(json|s?end|cork|sendFile)/g.test(middleware.toString())) ||
        middleware.toString().indexOf('next') === -1;
    }

    return this;
  }
  _prepareMethod(method, { originalUrl, path, ...options }, ...middlewares) {
    // eslint-disable-next-line no-unused-vars
    const { _config, _baseUrl, _middlewares, _module, _rootLevel, _ajv } = this;

    const fetchMethod = method.toUpperCase() === 'ANY';
    const isWebSocket = method === 'WS';
    const fetchUrl = path.indexOf('*') !== -1 || path.indexOf(':') !== -1;
    let validation = null;
    let _direct = false;
    let _schema = null;
    let isAborted = false;
    let isNotFoundHandler = false;
    const bodyAllowedMethod =
      method === 'POST' || method === 'PUT' || method === 'PATCH';
    let responseSchema;

    const findConfig = middlewares.find(
      (middleware) =>
        typeof middleware === 'object' &&
        middleware &&
        (middleware.isRaw !== undefined ||
          middleware.isStrictRaw !== undefined ||
          middleware.forceRaw !== undefined ||
          middleware.noMiddleware !== undefined ||
          middleware.onAborted ||
          middleware.schema)
    );
    const isRaw = findConfig && findConfig.isRaw;
    const isStrictRaw = findConfig && findConfig.isStrictRaw;
    const forceRaw = findConfig && findConfig.forceRaw;
    const noMiddleware = findConfig && findConfig.noMiddleware;
    const onAborted = findConfig && findConfig.onAborted;
    let schema = findConfig && findConfig.schema && findConfig;

    let isCanCompiled = false;
    let compilePath;
    let compileMethod;
    let experimentalBodyParser;

    middlewares = middlewares
      .filter((middleware) => typeof middleware === 'function')
      .filter((middleware, i, self) => self.indexOf(middleware) === i);

    if (_middlewares && _middlewares.length > 0) {
      middlewares = _middlewares.concat(middlewares);
    }

    if (noMiddleware) {
      middlewares.length = 0;
    }

    let routeFunction = middlewares.pop();

    // Quick dirty hack to performance improvement
    if (forceRaw) {
      return (res, req) => routeFunction(req, res);
    }

    // Filter middlewares before Compile to methods matching
    // to keep performance up-to-date
    middlewares = middlewares.filter((middleware) => {
      if (middleware.methods) {
        if (!middleware.methods.includes(method)) {
          return false;
        }
      }
      return middleware;
    });

    // Prepare params
    const preparedParams =
      (!_schema || _schema.params !== false) && prepareParams(path);

    // Quick dirty hack to performance improvement
    if (!isCanCompiled && middlewares.length === 0) {
      const compile = compileRoute(routeFunction, preparedParams);

      if (compile) {
        isCanCompiled = true;
        routeFunction = compile;
        compileMethod = compile.method;
        compilePath = compile.path;
      }
    }

    if (typeof path === 'function' && !routeFunction) {
      _direct = true;
      routeFunction = path;
    } else if (typeof schema === 'function' && !routeFunction) {
      routeFunction = schema;
      schema = null;
    }

    if (!fetchUrl && path.length > 1 && path.charAt(path.length - 1) === '/') {
      path = path.substr(0, path.length - 1);
    }

    const isShouldReduceTaks = isCanCompiled || isStrictRaw;
    if (!isShouldReduceTaks && !isRaw) {
      _schema = (schema && schema.schema) || undefined;
      experimentalBodyParser =
        _schema &&
        _schema.body &&
        turboJsonParse(_schema.body, {
          defaults: false,
          validate: false,
          fullMatch: true,
          buffer: false
        });
      validation = _schema && prepareValidation(_ajv, _schema);
      // eslint-disable-next-line prefer-const
      responseSchema = _schema && validation && validation.responseSchema;

      isNotFoundHandler = routeFunction.handler === 2;
      if (
        method !== 'options' &&
        (routeFunction.then ||
          routeFunction.constructor.name === 'AsyncFunction')
      ) {
        if (!/res\.(s?end|json)/g.test(routeFunction.toString())) {
          const _oldRouteFunction = routeFunction;
          routeFunction = async (req, res) => {
            const data = await _oldRouteFunction(req, res);
            if (!isAborted && data && data !== res) {
              isAborted = true;
              return res.send(data);
            }
            return null;
          };
        }
        routeFunction.isAsync = true;
      }

      middlewares = middlewares
        .filter((middleware, index, self) => self.indexOf(middleware) === index)
        .map((middleware) => {
          if (middleware.override && isNotFoundHandler) {
            isNotFoundHandler = false;
          }

          if (middleware._module) {
            return null;
          } else if (
            middleware.then ||
            middleware.constructor.name === 'AsyncFunction'
          ) {
            return middleware;
          } else {
            const _oldMiddleware = middleware;
            middleware = function (req, res) {
              return new Promise((resolve, reject) => {
                _oldMiddleware(req, res, (err, done) => {
                  if (err) {
                    reject(err);
                  } else {
                    resolve(done);
                  }
                });
              });
            };
          }
          return middleware;
        })
        .filter((middleware) => typeof middleware === 'function');
    }

    if (_config && _config.swagger && schema) {
      swaggerDocsGenerator(
        _config.swagger,
        originalUrl,
        method.toLowerCase(),
        schema
      );
    }

    if (originalUrl.length > 1 && originalUrl.endsWith('/')) {
      originalUrl = originalUrl.substr(0, originalUrl.length - 1);
    }

    const _onAbortedCallbacks = (!isShouldReduceTaks || isWebSocket) && [];
    const _handleOnAborted =
      (!isShouldReduceTaks || isWebSocket) &&
      (() => {
        isAborted = true;
        if (onAborted) {
          onAborted();
        }
        if (_onAbortedCallbacks.length > 0) {
          for (let i = 0, len = _onAbortedCallbacks.length; i < len; i++) {
            _onAbortedCallbacks[i]();
          }
          _onAbortedCallbacks.length = 0;
        }
      });

    const attachOnAborted =
      (!isShouldReduceTaks || isWebSocket) &&
      ((fn) => {
        _onAbortedCallbacks.push(fn);
      });

    const handler =
      isShouldReduceTaks && !isWebSocket
        ? !compilePath && !compileMethod
          ? (res, req) => routeFunction(req, res)
          : (res, req) => {
              req.method = fetchMethod ? req.getMethod().toUpperCase() : method;
              req.path = fetchUrl ? req.getUrl().substr(_baseUrl.length) : path;
              req.baseUrl = _baseUrl || '';

              // Cache value
              const reqPathLength = req.path.length;

              if (
                fetchUrl &&
                reqPathLength > 1 &&
                req.path.charAt(reqPathLength - 1) === '/'
              ) {
                req.path = req.path.substr(0, reqPathLength - 1);
              }

              // Aliases for polyfill
              req.url = req.path;
              req.originalUrl = originalUrl;

              return routeFunction(req, res);
            }
        : async (res, req) => {
            isAborted = false;
            _onAbortedCallbacks.length = 0;
            !isRaw && res.onAborted(_handleOnAborted);
            attachOnAborted(() => {
              res.aborted = true;
            });
            res[resAbortHandler] = true;

            req.method = fetchMethod ? req.getMethod().toUpperCase() : method;
            req.path = fetchUrl ? req.getUrl().substr(_baseUrl.length) : path;
            req.baseUrl = _baseUrl || '';

            // Cache value
            const reqPathLength = req.path.length;

            // Cache function
            const handleError = (err) => {
              isAborted = true;

              res.writeHeader(
                'Content-Type',
                'application/json; charset=utf-8'
              );

              if (_config._errorHandler) {
                return _config._errorHandler(err, req, res);
              }

              res.status(err.status || err.code || 400, true);
              res.writeStatus(res.statusCode);

              res.end(
                `{"error":"${typeof err === 'string' ? err : err.message}"}`
              );

              return res;
            };

            if (
              fetchUrl &&
              reqPathLength > 1 &&
              req.path.charAt(reqPathLength - 1) === '/'
            ) {
              req.path = req.path.substr(0, reqPathLength - 1);
            }

            // Aliases for polyfill
            req.url = req.path;
            req.originalUrl = originalUrl;

            // Some callbacks which need for your
            req.onAborted = attachOnAborted;

            // Aliases for future usage and easy-access
            if (!isRaw) {
              req.__response = res;
              res.__request = req;

              // Extending proto
              const { __proto__ } = res;
              for (const newMethod in HttpResponse) {
                __proto__[newMethod] = HttpResponse[newMethod];
              }
              req.getIP = res._getResponseIP;
              res.writeHead.notModified = true;
            }

            // Default HTTP Raw Status Code Integer
            res.rawStatusCode = 200;

            // Assign schemas
            if (responseSchema) {
              res.fastJson = responseSchema;
            }
            if (experimentalBodyParser) {
              req.fastBodyParse = experimentalBodyParser;
            }

            if (!isRaw && _schema !== false) {
              if (!_schema || _schema.headers !== false) {
                req.headers = headers(req, _schema && _schema.headers);
              }
              if (!_schema || _schema.cookies !== false) {
                req.cookies = cookies(req, _schema && _schema.cookies);
              }
              if (!_schema || _schema.params !== false) {
                if (req.path !== path) {
                  path = req.path;
                }
                req.params = params(req, preparedParams);
              }
              if (!_schema || _schema.query !== false) {
                req.query = queries(req, _schema && _schema.query);
              }
              if (!isRaw && bodyAllowedMethod && res.onData) {
                stream(req, res);
                req.pipe = pipe;
              }
              if (req.stream && (!_schema || _schema.body !== false)) {
                await body(req);
              }
            }

            if (
              !isRaw &&
              !isAborted &&
              !isNotFoundHandler &&
              middlewares &&
              middlewares.length > 0
            ) {
              for (const middleware of middlewares) {
                if (isAborted) {
                  break;
                }

                const response = await middleware(req, res).catch(handleError);

                if (response === res) {
                  return;
                }
              }
            }

            if (
              isAborted ||
              method === 'OPTIONS' ||
              res.stream === true ||
              res.stream === 1
            ) {
              return;
            }

            if (_direct || !fetchUrl || req.path === path) {
              if (
                !isRaw &&
                !res._modifiedEnd &&
                (!res.writeHead.notModified ||
                  (res.statusCode && res.statusCode !== 200) ||
                  res._headers)
              ) {
                res.modifyEnd();
              }

              if (
                isAborted ||
                (!isRaw &&
                  validation &&
                  validation.validationStringify &&
                  processValidation(req, res, _config, validation))
              ) {
                return;
              }

              if (routeFunction.isAsync) {
                return routeFunction(req, res).catch(handleError);
              } else {
                return routeFunction(req, res);
              }
            }
          };

    if (isWebSocket) {
      Object.assign(
        options,
        {
          compression: 0,
          maxPayloadLength: 16 * 1024 * 1024,
          idleTimeout: 120
        },
        options
      );

      return {
        ...options,
        open(ws) {
          ws.emit('connection', ws);
        },
        async upgrade(res, req, context) {
          if (!res.___events) {
            res.on = __wsProto__.on;
            res.once = __wsProto__.once;
            res.off = __wsProto__.off;
            res.emit = __wsProto__.emit;

            res.___events = [];
          }

          await handler(res, req);

          res.emit('upgrade', req, res);

          res.upgrade(
            Object.assign({ req }, res),
            /* Spell these correctly */
            req.headers['sec-websocket-key'],
            req.headers['sec-websocket-protocol'],
            req.headers['sec-websocket-extensions'],
            context
          );
        },
        message: (ws, message, isBinary) => {
          if (!isBinary) {
            message = Buffer.from(message).toString('utf8');
          }
          if (options.schema) {
            if (typeof message === 'string') {
              if (message.indexOf('[') === 0 || message.indexOf('{') === 0) {
                if (message.indexOf('[object') === -1) {
                  message = JSON.parse(message);

                  const valid = validation(message);
                  if (!valid) {
                    ws.emit(
                      'message',
                      {
                        type: 'websocket.message',
                        errors: validation.errors.map((err) => err.message)
                      },
                      isBinary
                    );
                    return;
                  }
                }
              }
            }
          }
          ws.emit('message', message, isBinary);
        },
        drain: (ws) => {
          ws.emit('drain', ws.getBufferedAmount());
        },
        close: (ws, code, message) => {
          ws.emit('close', code, Buffer.from(message).toString('utf8'));
        }
      };
    } else {
      return handler;
    }
  }
}

const exposeMethod = (method) =>
  function (path, ...middlewares) {
    const { _baseUrl, _module, _app } = this;

    let originalUrl = path;
    if (middlewares.length > 0) {
      if (_baseUrl !== '' && _module && originalUrl.indexOf(_baseUrl) === -1) {
        originalUrl = _baseUrl + path;
      }

      const preparedRouteFunction = this._prepareMethod(
        method.toUpperCase(),
        { path, originalUrl },
        ...middlewares
      );

      _app[method](originalUrl, preparedRouteFunction);
    }

    return this;
  };

for (let i = 0, len = httpMethods.length; i < len; i++) {
  const method = httpMethods[i];
  Route.prototype[method] = exposeMethod(method);
}

Route.prototype.ws = exposeMethod('ws');

class App {
  get config() {
    return this._config;
  }
  get host() {
    const { _config: config } = this;
    return config.host;
  }
  get port() {
    const { _config: config } = this;
    return config.port;
  }
  get address() {
    const { _config: config } = this;
    let address = '';
    if (config.host) {
      address += config.https ? 'https://' : 'http://';
      address += config.host || 'localhost';

      if (config.port) {
        address += ':' + config.port;
      }
    }

    return address;
  }
  constructor(config, app, route) {
    this._config = config;
    this._app = app;
    this._route = route;

    this.time = Date.now();

    this._instance = null;

    if (config && config.swagger) {
      this.activateDocs();
    }

    this._routeCalled = false;
    this._optionsCalled = false;

    this._console = config.console || console;

    return this;
  }
  activateDocs() {
    this._app.get('/docs/swagger.json', (res) => {
      res.writeHeader('Content-Type', 'application/json; charset=utf-8');
      res.end(JSON.stringify(this._config.swagger, null, 4));
    });
  }
  setErrorHandler(fn) {
    this._config._errorHandler = fn;

    return this;
  }
  setNotFoundHandler(fn) {
    this._config._notFoundHandler = fn;

    return this;
  }
  setValidationErrorHandler(fn) {
    this._config._validationErrorHandler = fn;

    return this;
  }
  use(...args) {
    this._route.use(...args);

    return this;
  }
  define(callback) {
    callback(this);

    return this;
  }
  // TODO:
  // Beta `app.publish` method
  // when i will i have time, i will improve this wrapping
  publish(topic, string, isBinary, compress) {
    this._app.publish(topic, string, isBinary, compress);
  }
  listen(port, host) {
    const {
      _config: config,
      _app: app,
      _routeCalled,
      _optionsCalled,
      _console
    } = this;

    if (typeof port === 'string') {
      if (port.indexOf('.') !== -1) {
        const _host = host;

        host = port;
        port = _host || undefined;
      }
    }

    if (!_routeCalled) {
      const _errorContext = _console.error ? _console : console;

      _errorContext.error(
        'nanoexpress [Server]: None of middleware will be called until you define route'
      );
    }

    // Polyfill for plugins like CORS
    // Detaching it from every method for performance reason
    if (_routeCalled && !_optionsCalled) {
      this.options('/*', () => {});
    }

    if (!this._anyRouteCalled) {
      const notFoundHandler =
        config._notFoundHandler ||
        ((req, res) => {
          res.statusCode = 404;
          res.send({ code: 404, message: 'The route does not exist' });
        });
      notFoundHandler.handler = 2;
      this.get('/*', notFoundHandler);
    }

    return new Promise((resolve, reject) => {
      if (port === undefined) {
        const _errorContext = _console.error ? _console : console;

        _errorContext.error('[Server]: PORT is required');
        return undefined;
      }
      port = Number(port);

      const onListenHandler = (token) => {
        if (typeof host === 'string') {
          config.host = host;
        } else {
          config.host = 'localhost';
        }
        if (typeof port === 'number') {
          config.port = port;
        }

        if (token) {
          const _debugContext = _console.debug ? _console : console;

          this._instance = token;
          _debugContext.debug(
            `[Server]: started successfully at [${config.host}:${port}] in [${
              Date.now() - this.time
            }ms]`
          );
          resolve(this);
        } else {
          const _errorContext = _console.error ? _console : console;

          _errorContext.error(
            `[Server]: failed to host at [${config.host}:${port}]`
          );
          reject(
            new Error(`[Server]: failed to host at [${config.host}:${port}]`)
          );
          config.host = null;
          config.port = null;
        }
      };

      if (host) {
        app.listen(host, port, onListenHandler);
      } else {
        app.listen(port, onListenHandler);
      }
    });
  }
  close() {
    const { _config: config, _console } = this;

    if (this._instance) {
      const _debugContext = _console.debug ? _console : console;

      config.host = null;
      config.port = null;
      uWS.us_listen_socket_close(this._instance);
      this._instance = null;
      _debugContext.debug('[Server]: stopped successfully');
      return true;
    } else {
      const _errorContext = _console.error ? _console : console;

      _errorContext.error('[Server]: Error, failed while stopping');
      return false;
    }
  }
}

const exposeAppMethod = (method) =>
  function (path, ...fns) {
    const { _app, _route, _anyRouteCalled } = this;

    if (fns.length > 0) {
      const preparedRouteFunction = _route._prepareMethod(
        method.toUpperCase(),
        { path, originalUrl: path },
        ...fns
      );

      _app[method](path, preparedRouteFunction);

      this._routeCalled = true;

      if (!_anyRouteCalled && method !== 'options') {
        this._anyRouteCalled = path === '/*';
      }

      if (method === 'options') {
        this._optionsCalled = true;
      }
    }
    return this;
  };

for (let i = 0, len = httpMethods.length; i < len; i++) {
  const method = httpMethods[i];
  App.prototype[method] = exposeAppMethod(method);
}

App.prototype.ws = exposeAppMethod('ws');

class Config {
  get https() {
    return this._options.https !== undefined && this._options.isSSL !== false;
  }
  get swagger() {
    return this._options.swagger;
  }
  get console() {
    return this._options.console;
  }
  constructor(options = {}) {
    this._options = options;

    this.host = null;
    this.port = null;

    this.ajv = new Ajv(options.ajv);

    this.configureAjv = options.configureAjv;

    if (options.configureAjv) {
      this.ajv = options.configureAjv(this.ajv);
    }

    return this;
  }
}

const nanoexpress = (options = {}) => {
  let app;

  if (options.https && options.isSSL !== false) {
    app = uWS.SSLApp(options.https);
  } else {
    app = uWS.App();
  }
  // App configuration
  const config = new Config(options);

  // Initialize Route instance
  const routeInstance = new Route(config);
  routeInstance._app = app;
  routeInstance._rootLevel = true;

  // Initialize App instance
  return new App(config, app, routeInstance);
};

module.exports = nanoexpress;
//# sourceMappingURL=nanoexpress.js.map
