'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var http = _interopDefault(require('http'));
var https = _interopDefault(require('https'));

// Code was used from
// https://flaviocopes.com/webrtc/
// thank you

var webrtcServer = (app) => {
  app.webRTCServer = (path = '/webrtc', options = {}, ajv) => {
    const connections = {};

    app.ws(
      path,
      options,
      (req, ws) => {
        ws.on(
          'message',
          ({ action, error, credentials: { id, targetId } = {}, payload }) => {
            switch (action) {
              case 'register': {
                if (connections[id]) {
                  ws.send(
                    JSON.stringify({ action: 'register', success: false })
                  );
                } else {
                  connections[id] = ws;
                  ws.id = id;

                  ws.send(
                    JSON.stringify({ action: 'register', success: true })
                  );
                }
                break;
              }
              case 'offer': {
                const connection = connections[targetId];

                if (connection) {
                  connection.targetId = ws.id;
                  ws.targetId = targetId;

                  connection.send(
                    JSON.stringify({
                      action,
                      credentials: { sourceId: connection.id },
                      payload
                    })
                  );
                }
                break;
              }
              case 'answer':
              case 'candidate': {
                const connection = connections[ws.targetId];
                if (connection) {
                  connection.send(
                    JSON.stringify({
                      action,
                      payload
                    })
                  );
                }
                break;
              }
              case 'close': {
                const { targetId: wsId } = ws;
                const connection = connections[wsId];

                if (connection) {
                  connection.send(JSON.stringify({ action: 'close' }));
                }
                break;
              }
              default: {
                ws.send(
                  JSON.stringify({
                    action: 'error',
                    error: error || `action[${action}] not found`
                  })
                );
                break;
              }
            }
          }
        );
        ws.on('close', () => {
          const { id, targetId } = ws;

          connections[id] = null;
          delete connections[id];

          ws.id = null;
          ws.targetId = null;
          ws = null;

          const targetConnection = connections[targetId];

          if (targetConnection) {
            targetConnection.send(JSON.stringify({ action: 'close' }));

            // Clean target user too
            connections[targetId] = null;
            delete connections[targetId];
          }
        });
      },
      ajv
    );

    return app;
  };
};

http.globalAgent.keepAlive = true;
https.globalAgent.keepAlive = true;

const httpRequest = (agent, url, config) =>
  new Promise((resolve, reject) => {
    agent[config.method](url, config, (response) => {
      let buff;
      response.on('data', (chunk) => {
        chunk = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);

        if (!buff) {
          buff = chunk;
        } else {
          buff = Buffer.concat([buff, chunk]);
        }
      });
      response.on('end', () => {
        response.data = buff;

        resolve(response);
      });
      response.on('error', reject);
    });
  });

const prepareProxy = (
  path,
  {
    url,
    method,
    enableHeadersProxy = false,
    restrictedHeaders = [
      'Host',
      'Content-Length',
      'uWebSockets',
      'Accept-Encoding'
    ]
  } = {},
  wsInstance
) => {
  const isAny = method === undefined;
  const fetchUrl = url.indexOf('*') !== -1 || url.indexOf(':') !== -1;
  const proxyPathLen = fetchUrl ? path.length : 0;
  const disallowedHeaders = restrictedHeaders.map((header) =>
    header.toLowerCase()
  );

  // Prepared object to return
  const prepared = {
    isAny
  };

  const ssl = url.indexOf('https:') === 0;
  const agent = ssl ? https : http;

  if (method) {
    method = method.toLowerCase();
  }

  // HTTP Request configuration
  const config = {
    url,
    method,
    headers: {}
  };

  prepared.method = isAny ? 'any' : method;
  prepared.http = async (res, req) => {
    // Allow waiting for request finishing
    let isAborted = false;
    res.onAborted(() => {
      isAborted = true;
    });

    // Fetch needed methods and configure
    const httpUrl = fetchUrl ? url + req.getUrl().substr(proxyPathLen) : url;

    config.method = isAny ? req.getMethod() : method;

    // Proxy headers too if it's defined
    if (enableHeadersProxy) {
      req.forEach((key, value) => {
        if (disallowedHeaders.indexOf(key) === -1) {
          config.headers[key] = value;
        }
      });
    }

    const { data, headers } = await httpRequest(agent, httpUrl, config);

    if (isAborted) {
      return;
    }

    res.cork(() => {
      if (isAborted) {
        return;
      }

      if (enableHeadersProxy) {
        for (const key in headers) {
          const value = headers[key];

          if (disallowedHeaders.indexOf(key) !== -1) {
            continue;
          }

          if (typeof value === 'string') {
            res.writeHeader(key, value);
          } else if (value.splice) {
            for (let i = 0, len = value.length; i < len; i++) {
              res.writeHeader(key, value[i]);
            }
          }
        }
      }

      res.end(data);
    });
  };
  if (wsInstance) {
    prepared.ws = {
      open(ws, req) {
        config.method = 'ws';

        const wsUrl =
          url.replace(/http/, 'ws') +
          (fetchUrl ? req.getUrl().substr(proxyPathLen) : '');

        ws.instance = new wsInstance(wsUrl);

        ws.instance.on('message', (data) => {
          ws.send(data);
        });

        ws.instance.emit('open');
      },
      message(ws, message, isBinary) {
        if (!isBinary) {
          message = Buffer.from(message).toString('utf8');
        }

        ws.instance.send(message);
      },
      close(ws, code, reason) {
        ws.instance.close(code, reason);
      }
    };
  }

  return prepared;
};

var proxy = (app) => {
  app.proxy = (path, config, wsInstance) => {
    const { ws, http, method } = prepareProxy(path, config, wsInstance);

    if (http) {
      app._app[method](path, http);
    }
    if (ws) {
      app._app.ws(path, ws);
    }
    return app;
  };
};

exports.proxy = proxy;
exports.webRTCServer = webrtcServer;
//# sourceMappingURL=index.js.map
